syntax = "proto3";

package wings.v1.cluster_metadata;

import "google/protobuf/empty.proto";

// Cluster metadata service to manage cluster resources.
service ClusterMetadataService {
  // Create a new tenant.
  rpc CreateTenant(CreateTenantRequest) returns (Tenant) {}
  // Return the specified tenant.
  rpc GetTenant(GetTenantRequest) returns (Tenant) {}
  // List all tenants.
  rpc ListTenants(ListTenantsRequest) returns (ListTenantsResponse) {}
  // Delete a tenant.
  //
  // The request fails if the tenant has any namespace.
  rpc DeleteTenant(DeleteTenantRequest) returns (google.protobuf.Empty) {}

  // Create a new namespace belonging to a tenant.
  rpc CreateNamespace(CreateNamespaceRequest) returns (Namespace) {}
  // Return the specified namespace.
  rpc GetNamespace(GetNamespaceRequest) returns (Namespace) {}
  // List all namespaces belonging to a tenant.
  rpc ListNamespaces(ListNamespacesRequest) returns (ListNamespacesResponse) {}
  // Delete a namespace.
  //
  // The request fails if the namespace has any topic.
  rpc DeleteNamespace(DeleteNamespaceRequest) returns (google.protobuf.Empty) {}

  // Create a new topic belonging to a namespace.
  rpc CreateTopic(CreateTopicRequest) returns (Topic) {}
  // Return the specified topic.
  rpc GetTopic(GetTopicRequest) returns (Topic) {}
  // List all topics belonging to a namespace.
  rpc ListTopics(ListTopicsRequest) returns (ListTopicsResponse) {}
  // Delete a topic.
  rpc DeleteTopic(DeleteTopicRequest) returns (google.protobuf.Empty) {}
}

message CreateTenantRequest {
  // The tenant id.
  string tenant_id = 1;

  // The tenant metadata.
  Tenant tenant = 2;
}

message GetTenantRequest {
  // The tenant name.
  //
  // Format: tenants/{tenant}
  string name = 1;
}

message ListTenantsRequest {
  // The number of tenants to return.
  //
  // Default: 100
  // Maximum: 1000.
  optional int32 page_size = 1;

  // The continuation token.
  optional string page_token = 2;
}

message ListTenantsResponse {
  // The tenants.
  repeated Tenant tenants = 1;

  // The continuation token.
  string next_page_token = 2;
}

message DeleteTenantRequest {
  // The tenant name.
  //
  // Format: tenants/{tenant}
  string name = 1;
}

message Tenant {
  // The tenant name.
  //
  // Format: tenants/{tenant}
  string name = 1;
}

message CreateNamespaceRequest {
  // The tenant that owns the namespace.
  //
  // Format: tenants/{tenant}
  string parent = 1;

  // The namespace id.
  string namespace_id = 2;

  // The namespace metadata.
  Namespace namespace = 3;
}

message GetNamespaceRequest {
  // The namespace name.
  //
  // Format: tenants/{tenant}/namespaces/{namespace}
  string name = 1;
}

message ListNamespacesRequest {
  // The parent tenant.
  //
  // Format: tenants/{tenant}
  string parent = 1;

  // The number of namespaces to return.
  //
  // Default: 100
  // Maximum: 1000.
  optional int32 page_size = 2;

  // The continuation token.
  optional string page_token = 3;
}

message ListNamespacesResponse {
  // The namespaces.
  repeated Namespace namespaces = 1;

  // The continuation token.
  string next_page_token = 2;
}

message DeleteNamespaceRequest {
  // The namespace name.
  //
  // Format: tenants/{tenant}/namespaces/{namespace}
  string name = 1;
}

message Namespace {
  // The namespace name.
  //
  // Format: tenants/{tenant}/namespaces/{namespace}
  string name = 1;

  // The size at which the current segment is flushed to object storage.
  uint64 flush_size_bytes = 2;

  // The maximum interval at which the current segment is flushed to object storage (in milliseconds).
  uint64 flush_interval_millis = 3;

  // The default object store configuration for the namespace.
  //
  // This is an opaque string used to create the object store client.
  string default_object_store_config = 4;

  // Configuration for the datalake storage
  oneof data_lake_config {
      IcebergInMemoryCatalog iceberg_in_memory_catalog = 5;
      IcebergRestCatalog iceberg_rest_catalog = 6;
  };
}

// In-memory iceberg catalog.
//
// This catalog will use the same object store as the namespace.
message IcebergInMemoryCatalog {}

// Iceberg REST catalog
message IcebergRestCatalog {}

message CreateTopicRequest {
  // The namespace that owns the topic.
  //
  // Format: tenants/{tenant}/namespaces/{namespace}
  string parent = 1;

  // The topic id.
  string topic_id = 2;

  // The topic metadata.
  Topic topic = 3;
}

message GetTopicRequest {
  // The topic name.
  //
  // Format: tenants/{tenant}/namespaces/{namespace}/topics/{topic}
  string name = 1;
}

message ListTopicsRequest {
  // The parent namespace.
  //
  // Format: tenants/{tenant}/namespaces/{namespace}
  string parent = 1;

  // The number of topics to return.
  //
  // Default: 100
  // Maximum: 1000.
  optional int32 page_size = 2;

  // The continuation token.
  optional string page_token = 3;
}

message ListTopicsResponse {
  // The topics.
  repeated Topic topics = 1;

  // The continuation token.
  string next_page_token = 2;
}

message DeleteTopicRequest {
  // The topic name.
  //
  // Format: tenants/{tenant}/namespaces/{namespace}/topics/{topic}
  string name = 1;

  // If set to true, also delete data associated with the topic.
  bool force = 2;
}

message Topic {
  // The topic name.
  //
  // Format: tenants/{tenant}/namespaces/{namespace}/topics/{topic}
  string name = 1;

  // The fields in the topic messages.
  bytes fields = 2;

  // The index of the field that is used to partition the topic.
  optional uint32 partition_key = 3;
}
