syntax = "proto3";

package wings.v1.cluster_metadata;

import "google/protobuf/empty.proto";

// Cluster metadata service to manage cluster resources.
service ClusterMetadataService {
  // Create a new tenant.
  rpc CreateTenant(CreateTenantRequest) returns (Tenant) {}
  // Return the specified tenant.
  rpc GetTenant(GetTenantRequest) returns (Tenant) {}
  // List all tenants.
  rpc ListTenants(ListTenantsRequest) returns (ListTenantsResponse) {}
  // Delete a tenant.
  //
  // The request fails if the tenant has any namespace.
  rpc DeleteTenant(DeleteTenantRequest) returns (google.protobuf.Empty) {}

  // Create a new namespace belonging to a tenant.
  rpc CreateNamespace(CreateNamespaceRequest) returns (Namespace) {}
  // Return the specified namespace.
  rpc GetNamespace(GetNamespaceRequest) returns (Namespace) {}
  // List all namespaces belonging to a tenant.
  rpc ListNamespaces(ListNamespacesRequest) returns (ListNamespacesResponse) {}
  // Delete a namespace.
  //
  // The request fails if the namespace has any topic.
  rpc DeleteNamespace(DeleteNamespaceRequest) returns (google.protobuf.Empty) {}

  // Create a new topic belonging to a namespace.
  rpc CreateTopic(CreateTopicRequest) returns (Topic) {}
  // Return the specified topic.
  rpc GetTopic(GetTopicRequest) returns (Topic) {}
  // List all topics belonging to a namespace.
  rpc ListTopics(ListTopicsRequest) returns (ListTopicsResponse) {}
  // Delete a topic.
  rpc DeleteTopic(DeleteTopicRequest) returns (google.protobuf.Empty) {}

  // Create a new object store belonging to a tenant.
  rpc CreateObjectStore(CreateObjectStoreRequest) returns (ObjectStore) {}
  // Return the specified object store.
  rpc GetObjectStore(GetObjectStoreRequest) returns (ObjectStore) {}
  // List all object stores belonging to a tenant.
  rpc ListObjectStores(ListObjectStoresRequest) returns (ListObjectStoresResponse) {}
  // Delete an object store.
  rpc DeleteObjectStore(DeleteObjectStoreRequest) returns (google.protobuf.Empty) {}

  // Create a new data lake belonging to a tenant.
  rpc CreateDataLake(CreateDataLakeRequest) returns (DataLake) {}
  // Return the specified data lake.
  rpc GetDataLake(GetDataLakeRequest) returns (DataLake) {}
  // List all data lakes belonging to a tenant.
  rpc ListDataLakes(ListDataLakesRequest) returns (ListDataLakesResponse) {}
  // Delete a data lake.
  rpc DeleteDataLake(DeleteDataLakeRequest) returns (google.protobuf.Empty) {}
}

message CreateTenantRequest {
  // The tenant id.
  string tenant_id = 1;

  // The tenant metadata.
  Tenant tenant = 2;
}

message GetTenantRequest {
  // The tenant name.
  //
  // Format: tenants/{tenant}
  string name = 1;
}

message ListTenantsRequest {
  // The number of tenants to return.
  //
  // Default: 100
  // Maximum: 1000.
  optional int32 page_size = 1;

  // The continuation token.
  optional string page_token = 2;
}

message ListTenantsResponse {
  // The tenants.
  repeated Tenant tenants = 1;

  // The continuation token.
  string next_page_token = 2;
}

message DeleteTenantRequest {
  // The tenant name.
  //
  // Format: tenants/{tenant}
  string name = 1;
}

message Tenant {
  // The tenant name.
  //
  // Format: tenants/{tenant}
  string name = 1;
}

message CreateNamespaceRequest {
  // The tenant that owns the namespace.
  //
  // Format: tenants/{tenant}
  string parent = 1;

  // The namespace id.
  string namespace_id = 2;

  // The namespace metadata.
  Namespace namespace = 3;
}

message GetNamespaceRequest {
  // The namespace name.
  //
  // Format: tenants/{tenant}/namespaces/{namespace}
  string name = 1;
}

message ListNamespacesRequest {
  // The parent tenant.
  //
  // Format: tenants/{tenant}
  string parent = 1;

  // The number of namespaces to return.
  //
  // Default: 100
  // Maximum: 1000.
  optional int32 page_size = 2;

  // The continuation token.
  optional string page_token = 3;
}

message ListNamespacesResponse {
  // The namespaces.
  repeated Namespace namespaces = 1;

  // The continuation token.
  string next_page_token = 2;
}

message DeleteNamespaceRequest {
  // The namespace name.
  //
  // Format: tenants/{tenant}/namespaces/{namespace}
  string name = 1;
}

message Namespace {
  // The namespace name.
  //
  // Format: tenants/{tenant}/namespaces/{namespace}
  string name = 1;

  // The size at which the current segment is flushed to object storage.
  uint64 flush_size_bytes = 2;

  // The maximum interval at which the current segment is flushed to object storage (in milliseconds).
  uint64 flush_interval_millis = 3;

  // The default object store configuration for the namespace.
  //
  // This is an opaque string used to create the object store client.
  string default_object_store = 4;

  // Configuration for the datalake storage
  oneof data_lake_config {
      IcebergInMemoryCatalog iceberg_in_memory_catalog = 5;
      IcebergRestCatalog iceberg_rest_catalog = 6;
  };
}

// In-memory iceberg catalog.
//
// This catalog will use the same object store as the namespace.
message IcebergInMemoryCatalog {}

// Iceberg REST catalog
message IcebergRestCatalog {}

message CreateTopicRequest {
  // The namespace that owns the topic.
  //
  // Format: tenants/{tenant}/namespaces/{namespace}
  string parent = 1;

  // The topic id.
  string topic_id = 2;

  // The topic metadata.
  Topic topic = 3;
}

message GetTopicRequest {
  // The topic name.
  //
  // Format: tenants/{tenant}/namespaces/{namespace}/topics/{topic}
  string name = 1;
}

message ListTopicsRequest {
  // The parent namespace.
  //
  // Format: tenants/{tenant}/namespaces/{namespace}
  string parent = 1;

  // The number of topics to return.
  //
  // Default: 100
  // Maximum: 1000.
  optional int32 page_size = 2;

  // The continuation token.
  optional string page_token = 3;
}

message ListTopicsResponse {
  // The topics.
  repeated Topic topics = 1;

  // The continuation token.
  string next_page_token = 2;
}

message DeleteTopicRequest {
  // The topic name.
  //
  // Format: tenants/{tenant}/namespaces/{namespace}/topics/{topic}
  string name = 1;

  // If set to true, also delete data associated with the topic.
  bool force = 2;
}

message Topic {
  // The topic name.
  //
  // Format: tenants/{tenant}/namespaces/{namespace}/topics/{topic}
  string name = 1;

  // The fields in the topic messages.
  bytes fields = 2;

  // The index of the field that is used to partition the topic.
  optional uint32 partition_key = 3;
}

message CreateObjectStoreRequest {
  // The tenant that owns the object store.
  //
  // Format: tenants/{tenant}
  string parent = 1;

  // The object store id.
  string object_store_id = 2;

  // The object store metadata.
  ObjectStore object_store = 3;
}

message GetObjectStoreRequest {
  // The object store name.
  //
  // Format: tenants/{tenant}/object-stores/{object-store}
  string name = 1;
}

message ListObjectStoresRequest {
  // The parent tenant.
  //
  // Format: tenants/{tenant}
  string parent = 1;

  // The number of object stores to return.
  //
  // Default: 100
  // Maximum: 1000.
  optional int32 page_size = 2;

  // The continuation token.
  optional string page_token = 3;
}

message ListObjectStoresResponse {
  // The object stores.
  repeated ObjectStore object_stores = 1;

  // The continuation token.
  string next_page_token = 2;
}

message DeleteObjectStoreRequest {
  // The object store name.
  //
  // Format: tenants/{tenant}/object-stores/{object-store}
  string name = 1;
}

message ObjectStore {
  // The object store name.
  //
  // Format: tenants/{tenant}/object-stores/{object-store}
  string name = 1;

  // Object store configuration.
  oneof object_store_config {
    AwsConfiguration aws = 2;
    AzureConfiguration azure = 3;
    GoogleConfiguration google = 4;
    S3CompatibleConfiguration s3_compatible = 5;
  }
}

message AwsConfiguration {}

message AzureConfiguration {}

message GoogleConfiguration {}

message S3CompatibleConfiguration {}

message CreateDataLakeRequest {
  // The tenant that owns the data lake.
  //
  // Format: tenants/{tenant}
  string parent = 1;

  // The data lake id.
  string data_lake_id = 2;

  // The data lake metadata.
  DataLake data_lake = 3;
}

message GetDataLakeRequest {
  // The data lake name.
  //
  // Format: tenants/{tenant}/data-lakes/{data-lake}
  string name = 1;
}

message ListDataLakesRequest {
  // The parent tenant.
  //
  // Format: tenants/{tenant}
  string parent = 1;

  // The number of data lakes to return.
  //
  // Default: 100
  // Maximum: 1000.
  optional int32 page_size = 2;

  // The continuation token.
  optional string page_token = 3;
}

message ListDataLakesResponse {
  // The data lakes.
  repeated DataLake data_lakes = 1;

  // The continuation token.
  string next_page_token = 2;
}

message DeleteDataLakeRequest {
  // The data lake name.
  //
  // Format: tenants/{tenant}/data-lakes/{data-lake}
  string name = 1;
}

message DataLake {
  // The data lake name.
  //
  // Format: tenants/{tenant}/data-lakes/{data-lake}
  string name = 1;

  // Data lake configuration.
  oneof data_lake_config {
    IcebergConfiguration iceberg = 2;
    ParquetConfiguration parquet = 3;
  }
}

message IcebergConfiguration {}

message ParquetConfiguration {}
